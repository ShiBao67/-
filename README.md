2025/10/17
#	哈希表
	直接定址法
	求余留数法：把不连续的关键字映射到连续的地址空间，但会有冲突问题
	冲突处理：线性探测法：冲突后依次探测下一个位置，直到遇到空闲位置。采用除留余数加线性探测，表长=元素总数/除留因子
	平方探测法：平方的顺序探测，表长=4k+3的质数
	拉链法：把所有同意词用单链表串起来，每个元素包含一个头指针，相当于一个一个的单链表
	class Solution {
	public:
    // 函数功能：计算字符串中「无重复字符的最长子串」的长度
    // 输入：字符串 s（例如 "abcabcbb"）
    // 输出：最长无重复子串的长度（例如 "abcabcbb" 的结果为 3，对应 "abc" 或 "bca" 等）
    int lengthOfLongestSubstring(string s) {
        // 用哈希集合存储当前窗口中的字符，实现 O(1) 时间复杂度的重复判断
        unordered_set<char> occ;
        // rk：右指针，初始化为 -1 表示「窗口右边界初始在字符串左侧（未包含任何字符）」
        // ans：记录最长无重复子串的长度，初始为 0
        int rk = -1, ans = 0;
        // n：字符串长度，避免多次调用 s.size()
        int n = s.size();
        
        // 左指针 i 从 0 开始遍历，每轮固定左指针，尝试扩展右指针
        for (int i = 0; i < n; ++i) {
            // 左指针右移时（i > 0），需移除窗口中「原左指针位置的字符」
            // 因为窗口范围从 [i-1, rk] 变为 [i, rk]，原左边界的字符已不在窗口内
            if (i != 0) {
                occ.erase(s[i-1]);
            }
            
            // 扩展右指针：只要右指针下一位（rk+1）未越界，且该位置字符不在当前窗口中
            // 就将该字符加入窗口，并右移右指针
            while (rk + 1 < n && !occ.count(s[rk + 1])) {
                occ.insert(s[rk + 1]);  // 将新字符加入窗口
                ++rk;  // 右指针右移，扩大窗口
            }
            
            // 此时窗口 [i, rk] 是「以 i 为左边界的最长无重复子串」
            // 计算当前窗口长度（rk - i + 1），更新最长长度 ans
            ans = max(ans, rk - i + 1);
        }
        
        return ans;
    }
};
